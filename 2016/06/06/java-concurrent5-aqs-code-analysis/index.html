<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>java并发编程之5——AQS-AbstractQueuedSynchronizer-源码分析 | 语言</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java并发编程之5——AQS-AbstractQueuedSynchronizer-源码分析</h1><a id="logo" href="/.">语言</a><p class="description">编程是一种美德，是促使一个人不断向上发展的一种原动力. . .</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java并发编程之5——AQS-AbstractQueuedSynchronizer-源码分析</h1><div class="post-meta">Jun 6, 2016<span> | </span><span class="category"><a href="/categories/Java/">Java</a><a href="/categories/Java/Java并发编程/">Java并发编程</a><a href="/categories/Java/Java并发编程/源码分析/">源码分析</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a href="/2016/06/06/java-concurrent5-aqs-code-analysis/#comments" class="ds-thread-count cloud-tie-join-count"><span style="font-size: 15px; color: #6E7173;" class="join-count">0</span><span> 条参与</span></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是AQS"><span class="toc-number">1.</span> <span class="toc-text">什么是AQS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何利用AQS编写自己的同步工具类"><span class="toc-number">2.</span> <span class="toc-text">如何利用AQS编写自己的同步工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS原理概述"><span class="toc-number">3.</span> <span class="toc-text">AQS原理概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS源码分析"><span class="toc-number">4.</span> <span class="toc-text">AQS源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node节点的定义"><span class="toc-number">4.1.</span> <span class="toc-text">Node节点的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS内部变量定义"><span class="toc-number">4.2.</span> <span class="toc-text">AQS内部变量定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS操作"><span class="toc-number">4.3.</span> <span class="toc-text">CAS操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独占模式构建等待队列的实现"><span class="toc-number">4.4.</span> <span class="toc-text">独占模式构建等待队列的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独占模式激活并移除等待队列的节点"><span class="toc-number">4.5.</span> <span class="toc-text">独占模式激活并移除等待队列的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享模式构建等待队列的实现"><span class="toc-number">4.6.</span> <span class="toc-text">共享模式构建等待队列的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享模式激活并移除等待队列的节点"><span class="toc-number">4.7.</span> <span class="toc-text">共享模式激活并移除等待队列的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#节点的取消"><span class="toc-number">4.8.</span> <span class="toc-text">节点的取消</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他代码分析。"><span class="toc-number">4.9.</span> <span class="toc-text">其他代码分析。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConditionObject节点的定义"><span class="toc-number">4.10.</span> <span class="toc-text">ConditionObject节点的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConditionObject的整体把握"><span class="toc-number">4.10.1.</span> <span class="toc-text">ConditionObject的整体把握</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建条件队列"><span class="toc-number">4.10.2.</span> <span class="toc-text">构建条件队列</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractQueudSynchronizer（AQS）是道格李java并发编程的基础，内部主要包括Node和ConditionObject两个内部类，基于Node节点构建了一个FIFO队列，用来存储等待锁的线程的队列。基于ConditionObject节点也构造了一个FIFO队列，用于存储因为某种原因已经获取到锁而又主动释放锁的线程的队列。在concurrent包下面的大部分的工具类都是以他为基础，包括CountDownLatch,Lock,ReadWriteLock,Semaphare,条件队列….等等。</p>
<h1 id="如何利用AQS编写自己的同步工具类"><a href="#如何利用AQS编写自己的同步工具类" class="headerlink" title="如何利用AQS编写自己的同步工具类"></a>如何利用AQS编写自己的同步工具类</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有基于AQS实现的同步工具类的实现方法都可以划归为以下三步：</p>
<ul>
<li>子类定义一个名称为Sync的静态内部类，该类继承子AQS</li>
<li>Sync类实现tryAcquire/tryRelease(独占式) tryAcquireShared/tryReleaseShare(共享式) 来管理状态，所有对状态的管理都是通过AQS的getState/setState/compareAndSetState/三个方法来管理的</li>
<li>构造函数实例化Sync类在实例化Sync类的同时，指定同步类的同步状态的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public  int getState() 返回同步器的状态</div><div class="line"></div><div class="line">public void setState(int arg) 设置同步状态</div><div class="line"></div><div class="line">public  boolean compareAndSetState(int expect,int target) 原子的方式更新状态，如果现在的状态是expect就更新的target</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AQS可以被定义为共享模式和排他模式，当他被定义为排他模式的时候，他会阻止其他线程获取同步器的状态，当他被定义为共享模式的时候其他线程就可以获取同步器的同步状态。</p>
<h1 id="AQS原理概述"><a href="#AQS原理概述" class="headerlink" title="AQS原理概述"></a>AQS原理概述</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AQS是一个运用模板方法设计模式的典型示例。AQS是Java并发框架的基础抽象类，他提供了：如何让线程入队，如何让线程出队，线程如何从等待队列转移到条件队列，以及线程如何从条件队列转移到等待队列等，模板方法。而每一个AQS的子类，所要做的事情是：如何决定线程的出队入队。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：Lock是基于AQS实现的同步工具类。引用场景是当前线程如果获取到了锁就执行锁保护的代码，当前线程没有获取到锁，就将当前线程加入到等待队列，直到有线程执行完锁的代码之后主动释放锁，当前线程才能继续尝试获取到锁。<br>他们的实现方式如下：</p>
<ul>
<li>Lock类有一个同步状态用来标识当前线程是否可以获取到锁。</li>
<li>如果当前线程没有获取到锁，就调用AQS的方法，让当前线程进入到等待队列。</li>
<li>其他线程执行完成之后，调用AQS的方法告知等待锁的线程队列，可以获取锁了。</li>
<li>AQS决定让哪一个线程去获取锁，并将其移除等待队列。<br><font color="red"><strong><em>所以一句话：AQS实现线程的入队，子类决定线程的入队。</em></strong></font><h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在查看AQS的源代码的时候请时刻记住：AQS的主要功能就是围绕等待线程的出队入队。<br><font color="red"><strong>注意本文对源代码按照功能进行了一定的重排序，试图提取出代码的逻辑主线，和整体流程。所以代码的顺序和源代码的顺序有一定的前后顺序调整</strong></font><h2 id="Node节点的定义"><a href="#Node节点的定义" class="headerlink" title="Node节点的定义"></a>Node节点的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">     <span class="comment">//标识当前节点是共享模式</span></div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">     <span class="comment">//标识当前节点是排他模式</span></div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">     </div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div><div class="line">     </div><div class="line">     <span class="comment">/*</span></div><div class="line">     * 标识线程的等待状态 取值有以上四种  </div><div class="line">     * 1 表示等待线程节点已取消 </div><div class="line">     * -1 表示当前线程节点需要被激活</div><div class="line">     * -2 表示当前线程节点，等待在条件队列上而不是等待队列上</div><div class="line">     * -3 表示当前线程节点的后续节点的acquireShare方法能够被无条件执行</div><div class="line">     */</div><div class="line">     <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">     </div><div class="line">     <span class="comment">//等待队列的前驱节点</span></div><div class="line">     <span class="keyword">volatile</span> Node prev;</div><div class="line">     <span class="comment">//等待队列的后继节点</span></div><div class="line">     <span class="keyword">volatile</span> Node next;</div><div class="line">     <span class="comment">//当前节点的线程</span></div><div class="line">     <span class="keyword">volatile</span> Thread thread;</div><div class="line">     <span class="comment">//条件队列的等待节点</span></div><div class="line">     Node nextWaiter;</div><div class="line">     <span class="comment">//判断当前节点是否是共享节点</span></div><div class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> nextWaiter == SHARED;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//获取当前节点的前驱节点</span></div><div class="line">     <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</div><div class="line">         Node p = prev;</div><div class="line">         <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">         <span class="keyword">else</span></div><div class="line">             <span class="keyword">return</span> p;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// 默认构造函数，用来建立初始化节点</span></div><div class="line">     Node() &#123; </div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// 等待队列使用的节点</span></div><div class="line">     Node(Thread thread, Node mode&#123; </div><div class="line">         <span class="keyword">this</span>.nextWaiter = mode;</div><div class="line">         <span class="keyword">this</span>.thread = thread;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//条件队列使用的节点</span></div><div class="line">     Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</div><div class="line">         <span class="keyword">this</span>.waitStatus = waitStatus;</div><div class="line">         <span class="keyword">this</span>.thread = thread;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AQS内部变量定义"><a href="#AQS内部变量定义" class="headerlink" title="AQS内部变量定义"></a>AQS内部变量定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//等待队列的头结点，当调用setHead方法的时候才会初始化，属于懒加载</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"><span class="comment">//等待队列的尾节点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"><span class="comment">//AQS队列的状态</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure>
<h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本方法调用的是JDK的内部unsafe类，是基于硬件保证原子的更新。</p>
<p><font color="red">如果这个值是“expert”就更新为“update”</font>是无锁并发的基础。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="独占模式构建等待队列的实现"><a href="#独占模式构建等待队列的实现" class="headerlink" title="独占模式构建等待队列的实现"></a>独占模式构建等待队列的实现</h2><p><strong>构建等待队列有很多的变种，有的加入了中断，有的加入了时间判断，但是根本的原理是一样的。这个例子是以无中断，无时间判断来讲解的。后面查看源代码的时候，会继续提到其他的方法。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acquire是AQS提供的非共享模式获取锁的入口，首先执行tryAcquire方法（<font color="red">由具体的子类实现，不同的子类有不同的实现方式，这个在后续分析Lock源代码的时候会结合起来。</font>），如果失败，表示该线程获取锁失败，就调用addWaiter方法，将当前线程加入到等待队列中，然后返回当前线程的node节点。将node节点传递给acquireQueued方法，如果node节点的前驱节点是头结点，就再次尝试获取到锁，如果获取锁成功（成功返回的是false不会执行selfInterrupt方法），就讲该节点设置为头结点，如果获取失败，就将当前节点的线程挂起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将传入的节点加入到等待队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">//将节点构造为等待节点（前面的构造方法已经讲过）</span></div><div class="line">        Node pred = tail;</div><div class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//如果为节点不为空，表示已经有节点了，就将该节点添加到等待队列</span></div><div class="line">            <span class="comment">//下面的方法是先将node节点的前驱节点指向尾节点，然后CAS将尾节点设置为node节点（设置尾节点的时候采用的是位移运算，所以看不到直接的设置地方）</span></div><div class="line">            node.prev = pred;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">                pred.next = node;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果尾节点为null，就构造初始队列将节点添加到队列的尾部</span></div><div class="line">        enq(node);</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待队列为空的情况下，无锁地构造初始等待队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//for循环，直到队列构造成功</span></div><div class="line">            Node t = tail;</div><div class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//第一次循环：队列为空，就构造一个节点设置为头结点</span></div><div class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                    tail = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//第二次循环执行到这里 首先将node节点的前驱节点指向尾节点，然后CAS设置node节点为尾节点</span></div><div class="line">                node.prev = t;</div><div class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                    t.next = node;</div><div class="line">                    <span class="keyword">return</span> t;</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p><font color="red">(在挂起当前线程之前进行最后一次挣扎)！！！！！</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在节点添加到了等待队列中的时候再次尝试获取到锁 这里的arg一般是0或者1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本方法的主要作用是看CAS是否能够成功，成功表示当前线程获取到了锁返回false（注意 成功返回false和我们平时理解的正好相反）,如果失败就将当前线程挂起，在AQS提供的公用的acquire方法中调用了他<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="comment">//获取node节点的前驱</span></div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="comment">/**</span></div><div class="line">                *如果node节点的前驱节点是头结点，</div><div class="line">                *并且CAS更新同步状态成功（表示获取到锁了）</div><div class="line">                *就返回false，这里的tryAcquire是由AQS的不同子类实现的。</div><div class="line">                *后面我会写专门的文章来解析这部分</div><div class="line">                */</div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//这里是独占方式所以tryAcquire返回的是boolean，只能是成功或者失败，对比后面分析的tryAcquireShared</span></div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> interrupted;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果上一个操作没有成功，就判断当前node节点的线程是否应该被挂起，</span></div><div class="line">                <span class="comment">//如果是，就尝试挂起这个节点对应的线程</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置头结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        head = node;</div><div class="line">        node.thread = <span class="keyword">null</span>;</div><div class="line">        node.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="独占模式激活并移除等待队列的节点"><a href="#独占模式激活并移除等待队列的节点" class="headerlink" title="独占模式激活并移除等待队列的节点"></a>独占模式激活并移除等待队列的节点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;激活并移除等待节点的过程，和加入等待节点的过程正好相反。首先调用子类的tryRelease方法，如果失败，就返回，如果tryRelease方法释放锁成功。就拿到队列的头结点。然后激活头结点的后继节点，激活的过程是，首先找到头结点的第一个后继有效节点，将其从队列中移除，然后激活这个节点对应的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">            Node h = head;</div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">                unparkSuccessor(h);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;激活node节点的后继节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取当前节点的状态</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 1 表示等待线程节点已取消 </div><div class="line">        * -1 表示当前线程节点需要被激活</div><div class="line">        * -2 表示当前线程节点，等待在条件队列上而不是等待队列上</div><div class="line">        * -3 表示当前线程节点的后续节点的acquireShare方法能够被无条件执行</div><div class="line">        */</div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">        </div><div class="line">        <span class="comment">//如果节点的状态不是已取消,就讲节点的状态设置为0</span></div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">//获取node节点的后继节点</span></div><div class="line">        Node s = node.next;</div><div class="line">        <span class="comment">//如果后继节点不合法，就一直循环，直到找到一个合法的后继节点</span></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            <span class="comment">//激活s节点，其实就是唤醒这个node节点对应的线程</span></div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="共享模式构建等待队列的实现"><a href="#共享模式构建等待队列的实现" class="headerlink" title="共享模式构建等待队列的实现"></a>共享模式构建等待队列的实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共享模式构建等待队列的实现的流程和独占模式构建等待队列的实现是一样的，唯一的不一样的地方是“tryAcquireShared”这个由子类实现的方法。他的过程是：首先尝试获取共享锁（注意这里返回的是整数，这是实现共享模式的关键。）如果失败（小于0），就构建一个共享节点添加到等待队列。并将当前线程挂起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireShared(arg);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        </div><div class="line">        在addWaiter中以Node.SHARE构建一个node节点，添加到node队列的结尾并返回构建的节点</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                获取node节点的前驱节点</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                </div><div class="line">                如果node节点的前驱节点是头结点，注意这里和独占式的区别，独占式在这里CAS设置状态</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    获取节点的状态</div><div class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        将node节点设置为头结点 ，如果r大于<span class="number">0</span>，原来的头结点的状态小于<span class="number">0</span>，就获取node节点的后继节点，如果后继节点为<span class="keyword">null</span>或者后继节点是共享节点，就激活node节点的后继节点</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="共享模式激活并移除等待队列的节点"><a href="#共享模式激活并移除等待队列的节点" class="headerlink" title="共享模式激活并移除等待队列的节点"></a>共享模式激活并移除等待队列的节点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共享模式释放节点的流程和独占模式释放节点的流程基本一致。首先尝试更新释放状态tryReleaseShared方法，由具体的子类实现，如果成功就激活头节点的后继节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;激活头结点的后继有效节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Node h = head; <span class="comment">//获取头结点</span></div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">                <span class="keyword">int</span> ws = h.waitStatus; <span class="comment">//获取头结点的状态</span></div><div class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;<span class="comment">//如果头节点线程节点需要被激活，就尝试更新头结点的状态为0，如果更新状态失败，就继续循环，如果更新状态成功，就激活头结点的有效后继节点。</span></div><div class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))&#123; <span class="comment">//更新状态失败，就继续循环</span></div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                 &#125;</div><div class="line">                    <span class="comment">//更新状态成功就激活头结点的有效后继节点</span></div><div class="line">                    unparkSuccessor(h);</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">//如果头结点的初始状态为0，就CAS将状态更新为-3，如果成功，就判断头结点是否被修改，</span></div><div class="line">                    <span class="keyword">continue</span>; <span class="comment">//CAS 失败就一直循环</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (h == head) <span class="comment">//如果头结点指针没有变化，就一直循环，否则，退出循环</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</div><div class="line">        Node h = head; <span class="comment">//记录下原来的头结点 </span></div><div class="line">        setHead(node);<span class="comment">//将node节点设置为头结点</span></div><div class="line">       </div><div class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</div><div class="line">            Node s = node.next; </div><div class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">//如果是共享节点就激活头结点的后继节点</span></div><div class="line">                doReleaseShared();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="节点的取消"><a href="#节点的取消" class="headerlink" title="节点的取消"></a>节点的取消</h2><p>将节点的前驱有效节点，和后继有效节点连接起来，取消当前节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        node.thread = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//获取node节点的有效的前驱节点</span></div><div class="line">        Node pred = node.prev;</div><div class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line"></div><div class="line">        <span class="comment">// 找到node节点的后继节点</span></div><div class="line">        Node predNext = pred.next;</div><div class="line"></div><div class="line">        <span class="comment">//将node节点的状态设置为取消</span></div><div class="line">        node.waitStatus = Node.CANCELLED;</div><div class="line"></div><div class="line">        <span class="comment">// 如果node节点是尾节点，就将node节点的前驱节点设置为尾节点，并将node前驱节点的后继节点设置为null</span></div><div class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</div><div class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果node节点不是尾节点  </span></div><div class="line">            <span class="keyword">int</span> ws;</div><div class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</div><div class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</div><div class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</div><div class="line">                pred.thread != <span class="keyword">null</span>) &#123;<span class="comment">//如果node前驱节点不是头结点，就将前驱节点的状态设置为SINGAL。</span></div><div class="line">                Node next = node.next;<span class="comment">//找到node节点的后继节点</span></div><div class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//前后链接取消node节点</span></div><div class="line">                    compareAndSetNext(pred, predNext, next);</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果node前驱节点是头节点，激活node节点的后继有效节点</span></div><div class="line">                unparkSuccessor(node);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            node.next = node; </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>根据node节点和node节点的前驱节点的状态（只有前驱节点的状态为SIGNAL时，后继节点才应该被挂起）判断node节点对应的线程是否应该挂起<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取前驱节点的状态</span></div><div class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">//如果前驱节点状态为SIGNAL，说明当前节点应该被挂起</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//如果前驱节点被取消就一直往前找，直到找到有效的前驱节点</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                node.prev = pred = pred.prev;</div><div class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">            pred.next = node; <span class="comment">//将node节点的前驱无效节点删除</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果前驱节点的状态非以上两种，就设置前驱节点的状态，并且，返回false</span></div><div class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他代码分析。"><a href="#其他代码分析。" class="headerlink" title="其他代码分析。"></a>其他代码分析。</h2><p>上面分析了AQS的整体执行流程图。下面这些方法其实和上面的方法功能都一样，只不过是加了一些中断判断，时间判断等。这里就不一一列出了。</p>
<h2 id="ConditionObject节点的定义"><a href="#ConditionObject节点的定义" class="headerlink" title="ConditionObject节点的定义"></a>ConditionObject节点的定义</h2><h3 id="ConditionObject的整体把握"><a href="#ConditionObject的整体把握" class="headerlink" title="ConditionObject的整体把握"></a>ConditionObject的整体把握</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">        </div><div class="line">        条件队列的第一个节点</div><div class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</div><div class="line">        条件队列的最后一个节点</div><div class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">       </div><div class="line">        ....................</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从整体上看ConditionObject有两个特征：</p>
<ul>
<li>实现了Condition接口（这个接口定义了基本的wait，notify方法）</li>
<li>可以序列化，但是所有的属性都是 transient </li>
</ul>
<h3 id="构建条件队列"><a href="#构建条件队列" class="headerlink" title="构建条件队列"></a>构建条件队列</h3><p>当获取到锁的线程由于某种原因释放了锁，那么在释放锁的过程会有如下的几个操作</p>
<ul>
<li>首先会以当前线程为节点，构造一个条件队列，并将条件队列“下挂”在这把锁上。</li>
<li>然后激活等待这把锁的其他的线程，让等待锁的线程去获取锁，并返回AQS的同步状态</li>
<li>如果添加到等待队列成功，就讲当前线程挂起</li>
<li>当其他线程调用signal之后，会从挂起的代码地方继续执行。去获取线程的锁，走获取线程锁的过程。 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">线程调用await释放当前锁。会首先以当前线程构造一个等待节点添加到等待队列中。</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            构造条件队列</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            激活等待队列的线程，并返回AQS的状态</div><div class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">            正常添加到条件队列就将当前线程挂起。直到被signal或者interrupt，才会退出循环继续执行后面的代码</div><div class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            调用signal之后会继续执行这里的方法，去尝试获取锁，这个前面的分析以及有了。</div><div class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>添加一个节点到条件队列，如果条件队列的最后一个节点被取消，就先遍历整个条件队列，将所有被取消的节点从条件队列中移除。然后以当前线程构造条件节点加入到队列的末尾。<br>注意：<font color="red">读者可能发现，这里将一个节点添加到条件队列的时候并没有进行加锁，或者CAS什么的。这是因为，构造条件队列的当前线程已经，获取到了锁。</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</div><div class="line">            Node t = lastWaiter;</div><div class="line">            </div><div class="line">            如果最后一个节点被取消就遍历整个等待队列节点，取消所以的等待节点线程</div><div class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">                t = lastWaiter;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            构造等待节点，添加到等待队列的末尾</div><div class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</div><div class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">                firstWaiter = node;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                t.nextWaiter = node;</div><div class="line">            lastWaiter = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>在每次加入新节点到等待队列的时候，遍历所有的等待队列节点，将所有已经取消的节点从等待队列中移除，这样做的目的是防止返回一个无效的等待节点 ，但是时间复杂度是O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</div><div class="line">            Node t = firstWaiter;</div><div class="line">            Node trail = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                Node next = t.nextWaiter;</div><div class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</div><div class="line">                    t.nextWaiter = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</div><div class="line">                        firstWaiter = next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        trail.nextWaiter = next;</div><div class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">                        lastWaiter = trail;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    trail = t;</div><div class="line">                t = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>激活等待当前锁的条件队列，并返回AQS的状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> savedState = getState();</div><div class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> savedState;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                node.waitStatus = Node.CANCELLED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果当前节点在条件队列并且等待进入等待队列，则返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> findNodeFromTail(node);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://guochenglai.com/2016/06/06/java-concurrent5-aqs-code-analysis/" data-id="cj3iubhwi00225hbgady16g64" class="article-share-link">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/并发编程/">并发编程</a><a href="/tags/AQS/">AQS</a><a href="/tags/源码分析/">源码分析</a></div><div class="post-nav"><a href="/2016/06/07/screen-no-kill-conversation/" class="pre">screen管理远程会话不被kill</a><a href="/2016/06/04/java-concurrent4-java-subsection-decompose/" class="next">java并发编程之4——Java锁分解锁分段技术</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script>var cloudTieConfig = {
  url: document.location.href,
  productKey: "4e7d0025e59f4202ad52afa122a96a8a",
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://guochenglai.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Guava教程/">Guava教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java命令工具/">Java命令工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java并发编程/">Java并发编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java并发编程/源码分析/">源码分析</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux常用技巧/">Linux常用技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac常用技巧/">Mac常用技巧</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac常用技巧/软件破解/">软件破解</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/字符编码/">字符编码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构面试精选/">数据结构面试精选</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/gcl272633743" title="我的CSDN博客" target="_blank">我的CSDN博客</a><ul></ul><a href="https://github.com/guochenglai/guochenglai.github.io" title="我的GitHub" target="_blank">我的GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">语言.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>