<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>java并发编程之9——如何理解Condtion | 语言</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-78419105-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java并发编程之9——如何理解Condtion</h1><a id="logo" href="/.">语言</a><p class="description">编程是一种美德，是促使一个人不断向上发展的一种原动力. . .</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java并发编程之9——如何理解Condtion</h1><div class="post-meta">Jun 26, 2016<span> | </span><span class="category"><a href="/categories/Java/">Java</a><a href="/categories/Java/Java并发编程/">Java并发编程</a><a href="/categories/Java/Java并发编程/源码分析/">源码分析</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a href="/2016/06/26/java-concurrent9-condtion-code-analysis/#comments" class="ds-thread-count cloud-tie-join-count"><span style="font-size: 15px; color: #6E7173;" class="join-count">0</span><span> 条评论</span></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现分析"><span class="toc-number">2.</span> <span class="toc-text">实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的获取和等待队列。"><span class="toc-number">2.1.</span> <span class="toc-text">锁的获取和等待队列。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-lock"><span class="toc-number">2.1.1.</span> <span class="toc-text">lock.lock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS-acquire"><span class="toc-number">2.1.2.</span> <span class="toc-text">AQS.acquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-tryAcquire"><span class="toc-number">2.1.3.</span> <span class="toc-text">lock.tryAcquire()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS-acquireQueued"><span class="toc-number">2.1.4.</span> <span class="toc-text">AQS.acquireQueued</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await挂起当前线程锁构成条件队列，激活等待队列等待线程"><span class="toc-number">2.2.</span> <span class="toc-text">await挂起当前线程锁构成条件队列，激活等待队列等待线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-ConditionObject-await"><span class="toc-number">2.3.</span> <span class="toc-text">AQS.ConditionObject.await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signal激活条件队列的线程"><span class="toc-number">2.4.</span> <span class="toc-text">signal激活条件队列的线程</span></a></li></ol></li></ol></div></div><div class="post-content"><p>在理解Condition之前首先要明白两个概念：</p>
<ul>
<li>等待队列：等待获取锁的线程构成的队列，称为等待队列</li>
<li>条件队列：已经获取到锁的线程由于某种原因释放了锁，等待signal信号，而构成的队列称为条件队列<a id="more"></a>
</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Condition和Lock总是分不开的。在前面的文章 <a href="http://guochenglai.com/2016/06/06/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B5%E2%80%94%E2%80%94AQS-AbstractQueuedSynchronizer-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AQS源码分析</a> 中对这两者的实现原理都有一定的分析。并且对 <a href="http://guochenglai.com/2016/06/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B7%E2%80%94%E2%80%94AQS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ReentrantLock/">Lock源码</a> 也进行了分析。本文将展开讨论一下Condition的实现原理和具体用途。</p>
<font color="red"><br>说明：<br>- 如下的例子简化了异常的处理过程，因为处理异常的地方如果做的很完善会影响读者理解程序的运行逻辑。如果在正常的开发过程，还是建议完整地处理异常<br>- 程序的整体构建逻辑是：任务1获取到锁，然后调用await方法，释放锁，让任务2去获取锁，当任务2获取锁，并执行完代码调用signal方法的时候，任务1会被唤醒并尝试获取锁。这时候只有当任务2执行完所有的任务并释放锁之后，任务1才可以获取到锁，继续执行。</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.qunar.dzs.datahub.common.conditions;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by guochenglai on 7/1/16.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ConditionTest.class);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">        <span class="keyword">final</span> Condition condition = lock.newCondition();</div><div class="line"></div><div class="line"></div><div class="line">        Runnable task1 = () -&gt; &#123;</div><div class="line">            lock.lock(); <span class="comment">//首先线程1获取到了锁</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" i already get a lock and do something"</span>);</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">//获取到了锁之后，做一些独占的任务</span></div><div class="line"></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" for some reason i give up this lock "</span>);</div><div class="line">                condition.await(); <span class="comment">//由于某种原因线程放弃了锁</span></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">//是否锁之后当前线程会 在这里 陷入休眠</span></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">//当接收到signal信号之后，线程会被唤醒，然后重新去获取到锁，如果获取成功 会从这里继续执行</span></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" i catch a signal to get the lock again "</span>);</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line"></div><div class="line">                <span class="comment">//执行完成之后记得释放锁</span></div><div class="line">                lock.unlock();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                lock.unlock(); <span class="comment">//发生异常了就释放锁</span></div><div class="line">                LOGGER.error(<span class="string">"task one cause exception "</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Runnable task2 = () -&gt; &#123;</div><div class="line">            lock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" task one  give up the lock i catch it "</span>); <span class="comment">//任务1释放了锁之后，这里线程2才可以获取到锁</span></div><div class="line"></div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">//任务2 做一些独占的任务</span></div><div class="line"></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * 任务2 做完任务之后告知等待当前条件的其他线程 可以去获取锁了，</div><div class="line">                 * 这时候任务1 会被唤醒，然后尝试获取锁，</div><div class="line">                 *</div><div class="line">                 * 这里需要注意的是任务1 在这里只是有机会去尝试获取锁，现在的</div><div class="line">                 * 锁还是被任务2 所占用，只有当任务2执行完成之后，释放了锁，任务1</div><div class="line">                 * 才可以真正的去获取锁</div><div class="line">                 */</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" notify task one to get lock and continue to do his work ..."</span>);</div><div class="line">                condition.signal();</div><div class="line"></div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">//任务2 做一些其他的任务</span></div><div class="line"></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" do some other work and release lock "</span>);</div><div class="line"></div><div class="line">                lock.unlock();</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                lock.unlock();</div><div class="line">                LOGGER.error(<span class="string">"task two cause exception "</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(task1).start(); <span class="comment">//这里让任务1先执行，因为设计的就是它先获取到锁，然后释放锁，最后被唤醒继续获取锁的过程</span></div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">        <span class="keyword">new</span> Thread(task2).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span> i already get a lock and <span class="keyword">do</span> something</div><div class="line">Thread-<span class="number">0</span> <span class="keyword">for</span> some reason i give up <span class="keyword">this</span> lock </div><div class="line">Thread-<span class="number">1</span> task one  give up the lock i <span class="keyword">catch</span> it </div><div class="line">Thread-<span class="number">1</span> notify task one to get lock and <span class="keyword">continue</span> to <span class="keyword">do</span> his work ...</div><div class="line">Thread-<span class="number">1</span> <span class="keyword">do</span> some other work and release lock </div><div class="line">Thread-<span class="number">0</span> i <span class="keyword">catch</span> a signal to get the lock again</div></pre></td></tr></table></figure></p>
<p>通过输出可以看到整个的处理流程如下：</p>
<ul>
<li>任务1获取到锁，执行独占的任务，同时任务2在等待获取锁</li>
<li>任务1由于某种原因，自己主动释放锁，并将自己陷入休眠</li>
<li>任务2发现锁可以获取了，就会去获取锁，执行自己的独占任务</li>
<li>任务2执行完自己的任务之后调用signal通知，等待队列的任务1去尝试获取锁。并且自己释放自己占有的锁</li>
<li>任务1，发现锁可以获取之后，会去获取锁并继续执行自己的任务。</li>
</ul>
<p>阅读上面的流程读者可能如下的疑问：<br>   1 任务一调用await之后，任务2是怎么知道锁是可以获取了，并去获取锁的。<br>   2 任务二调用signal之后，任务1又是怎么知道锁是可以获取的，并去获取锁的。<br>其实，这两个问题才是Condition的精髓。这其中涉及到条件队列和等待队列的相互转移。下面将结合源码详细分析。</p>
<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><h3 id="锁的获取和等待队列。"><a href="#锁的获取和等待队列。" class="headerlink" title="锁的获取和等待队列。"></a>锁的获取和等待队列。</h3><p>线程1获取到锁之后，线程2再次尝试获取锁的时候，就会将自己挂起构成等待队列，这个过程在前面的文章已经分析过了。这里将从lock.lock()方法开始，温习一下整个流程。</p>
<h4 id="lock-lock"><a href="#lock-lock" class="headerlink" title="lock.lock()"></a>lock.lock()</h4><p>lock.lock()方法，默认调用的非公平实现的lock方法。首先进行CAS如果成功，就设置锁的拥有者。否则调用AQS的acquire方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">                setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            <span class="keyword">else</span></div><div class="line">                acquire(<span class="number">1</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<h4 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire"></a>AQS.acquire</h4><p>AQS的acquire方法会再次调用lock.tryAcquire()方法尝试获取到锁，如果获取失败，就调用自己的addWaiter()和acquireQueued()方法，构造等待队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="lock-tryAcquire"><a href="#lock-tryAcquire" class="headerlink" title="lock.tryAcquire()"></a>lock.tryAcquire()</h4><p>当AQS的同步状态为0的时候，并且没有等待队列，并且CAS更新状态成功，就获取到锁，并设置锁的所有者。返回true<br>当AQS的同步状态不为0的时候，判断是否是重入锁，如果是就将同步状态加1。并返回true<br>其他情况都是获取锁失败，返回false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<h4 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a>AQS.acquireQueued</h4><p>addWaiter方法就是将当前线程构造成node节点并添加到等待队列的末尾，前面已经具体分析过实现，acquireQueued方法接受添加到队列的节点，在进行一次挣扎，如果失败，就将当前线程挂起<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> interrupted;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>至此，任务1在继续执行任务，任务2被挂起了，并构造了一个等待队列。</p>
<h3 id="await挂起当前线程锁构成条件队列，激活等待队列等待线程"><a href="#await挂起当前线程锁构成条件队列，激活等待队列等待线程" class="headerlink" title="await挂起当前线程锁构成条件队列，激活等待队列等待线程"></a>await挂起当前线程锁构成条件队列，激活等待队列等待线程</h3><p>当任务1由于某种原因调用await方法释放自己的锁的时候。会将自己休眠加入到条件队列，并激活等待队列的线程。实现过程如下：</p>
<h3 id="AQS-ConditionObject-await"><a href="#AQS-ConditionObject-await" class="headerlink" title="AQS.ConditionObject.await"></a>AQS.ConditionObject.await</h3><p>await方法，首先调用 AQS.ConditionObject. addConditionWaiter()方法构造一个条件队列。然后调用AQS.ConditionObject.fullyRelease()方法去激活等待队列上的等待线程（其实就是调用AQS.release方法），然后将当前线程挂起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">            <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</div><div class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(<span class="keyword">this</span>); <span class="comment">//调用await方法正常情况，当前线程会在这个地方被挂起，激活之后继续从这里执行。</span></div><div class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">                reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>AQS.release激活等待队列的线程去获取锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> savedState = getState();</div><div class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> savedState;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                node.waitStatus = Node.CANCELLED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="signal激活条件队列的线程"><a href="#signal激活条件队列的线程" class="headerlink" title="signal激活条件队列的线程"></a>signal激活条件队列的线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            Node first = firstWaiter;</div><div class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">                doSignal(first);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>根据传入的节点，找到第一个未被取消的节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</div><div class="line">                    lastWaiter = <span class="keyword">null</span>;</div><div class="line">                first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</div><div class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>将等待这个condition的节点由条件队列转移到等待队列，然后当当前线程释放锁之后，在等待队列的节点就可以继续去尝试获取到锁了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">               Node p = enq(node);</div><div class="line">        <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">            LockSupport.unpark(node.thread);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>整个处理流程，写了好久！！！！</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://guochenglai.com/2016/06/26/java-concurrent9-condtion-code-analysis/" data-id="cj3sq9pod0029sjbgr3yukwvd" class="article-share-link">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/并发编程/">并发编程</a><a href="/tags/AQS/">AQS</a><a href="/tags/源码分析/">源码分析</a><a href="/tags/条件队列/">条件队列</a></div><div class="post-nav"><a href="/2016/07/01/java-concurrent10-for-join-code-analysis/" class="pre">java并发编程之10——for/join框架</a><a href="/2016/06/22/java-concurrent8-semaphore-code-analysis/" class="next">java并发编程之8——AQS如何实现Semaphore</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script>var cloudTieConfig = {
  url: document.location.href,
  productKey: "4e7d0025e59f4202ad52afa122a96a8a",
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://guochenglai.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Guava教程/">Guava教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java命令工具/">Java命令工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java并发编程/">Java并发编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java并发编程/源码分析/">源码分析</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux常用技巧/">Linux常用技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac常用技巧/">Mac常用技巧</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac常用技巧/软件破解/">软件破解</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/字符编码/">字符编码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构面试精选/">数据结构面试精选</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/gcl272633743" title="我的CSDN博客" target="_blank">我的CSDN博客</a><ul></ul><a href="https://github.com/guochenglai/guochenglai.github.io" title="我的GitHub" target="_blank">我的GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">语言.</a> Powered by<a rel="nofollow" target="_blank" href="http://guochenglai.com/"> GuoChengLai.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?dddca6123bb9b862f15d6a9178ad4a2d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>